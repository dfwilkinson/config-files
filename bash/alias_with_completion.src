# alias_with_completion takes three or four arguments:
# $1: The name of the alias
# $2: The command to be aliased.  If "A:B" then A will be the command to alias
#       and B will be the command to use for completion,
#       otherwise $2 will be used for both.
# $3: The arguments for the command to alias all in one string
# $4: The arguments for the command to use for completion all in one string
#       [OPTIONAL and only used if :B specified in $2 above]
# Generate a wrapper completion function (completer) for an alias based on the
# command and the given arguments, if there is a completer for the command, and
# set the wrapper as the completer for the alias.
function alias_with_completion() {
  [[ "$#" == 3 ]] || [[ "$#" == 4 ]] || return 1

  local alias_name="$1"
  local aliased_command="${2%:*}"
  local completable_command="${2#*:}"
  local alias_arguments="$3"
  local completion_arguments="$3"
  if [ ${aliased_command} != ${completable_command} ] && [ ! -z "$4" ]; then
    local completion_arguments="$4"
  fi
  local num_completion_arguments=$(echo "${completion_arguments}" | wc -w)

  # The completion currently being used by the completable command.
  local completion=$(complete -p ${completable_command} 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F in this
  # current completion. This check will also catch commands with no completer
  # for which $completion will be empty.
  echo ${completion} | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that looks like:
  # something -F function_name something First strip the beginning of the string
  # up to the function name by removing "* -F " from the front.
  local completion_function=${completion##* -F }

  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function generated by this
  # function. This can happen when the user runs this twice for an alias like
  # ls='ls --color=auto' or alias l='ls' and alias ls='l foo'
  [ ${completion_function#$namespace} != ${completion_function} ] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
function ${wrapper_name}() {
  let COMP_CWORD+=${num_completion_arguments}
  args=( \"${completion_arguments}\" )
  COMP_WORDS=( ${completable_command} \${args[@]} \${COMP_WORDS[@]:1} )
  ${completion_function}
}"

  # To create the new completion we use the desired one with two replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F ${wrapper_name} }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} ${alias_name}"

  eval "${new_completion}"
  eval "alias ${alias_name}='${aliased_command} ${alias_arguments}'"
}
